<?xml version="1.0" encoding="UTF-8" ?>
<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<config>
  <!-- Lucene version: Re-index if this changes -->
  <luceneMatchVersion>8.4.1</luceneMatchVersion>
  
  <!-- Where to store the index -->
  <dataDir>${solr.data.dir:}</dataDir>

  <!-- How Lucene reads from the file system-->
  <directoryFactory name="DirectoryFactory" class="${solr.directoryFactory:solr.NRTCachingDirectoryFactory}"/>                    

  <!-- Don't ever change this. -->
  <codecFactory class="solr.SchemaCodecFactory"/>

  <!-- How Solr indexes stuff. A lot is default, but can be configured -->
  <indexConfig>
    <!-- Uses native fs locking -->
    <lockType>${solr.lock.type:native}</lockType>
  </indexConfig>
  
  <jmx />

  <!-- The default high-performance update handler -->
  <updateHandler class="solr.DirectUpdateHandler2">

    <!-- Enables a transaction log -->
    <updateLog>
      <str name="dir">${solr.ulog.dir:}</str>
      <int name="numVersionBuckets">${solr.ulog.numVersionBuckets:65536}</int>
    </updateLog>

    <!-- AutoCommit. Perform a hard commit automatically under certain conditions. -->
    <autoCommit>
      <maxTime>${solr.autoCommit.maxTime:15000}</maxTime>
      <openSearcher>false</openSearcher>
    </autoCommit>

    <!-- softAutoCommit is like autoCommit except it causes a
         'soft' commit which only ensures that changes are visible
         but does not ensure that data is synced to disk.  This is
         faster and more near-realtime friendly than a hard commit.
      -->
    <autoSoftCommit>
      <maxTime>${solr.autoSoftCommit.maxTime:-1}</maxTime>
    </autoSoftCommit>

  </updateHandler>

  <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       Query section - these settings control query time things like caches
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
  <query>

    <!-- Maximum number of clauses allowed when parsing a boolean query string. -->
    <maxBooleanClauses>${solr.max.booleanClauses:1024}</maxBooleanClauses>

    <!-- Cache used by SolrIndexSearcher for filters (DocSets) -->
    <filterCache class="solr.FastLRUCache"
                 size="512"
                 initialSize="512"
                 autowarmCount="0"/>

    <!-- Caches results of searches - ordered lists of document ids. -->
    <queryResultCache class="solr.LRUCache"
                      size="512"
                      initialSize="512"
                      autowarmCount="0"/>

    <!-- Caches Lucene Document objects (the stored fields for each document). -->
    <documentCache class="solr.LRUCache"
                   size="512"
                   initialSize="512"
                   autowarmCount="0"/>

    <!-- custom cache currently used by block join -->
    <cache name="perSegFilter"
           class="solr.search.LRUCache"
           size="10"
           initialSize="0"
           autowarmCount="10"
           regenerator="solr.NoOpRegenerator" />


    <!-- If true, stored fields that are not requested will be loaded lazily. -->
    <enableLazyFieldLoading>true</enableLazyFieldLoading>

    <!-- When a search is requested, a superset of the requested number of document ids are collected. -->
    <queryResultWindowSize>20</queryResultWindowSize>

    <!-- Maximum number of documents to cache for any entry in the queryResultCache. -->
    <queryResultMaxDocsCached>200</queryResultMaxDocsCached>

    <!-- Query Related Event Listeners -->
    <!-- Takes an array of NamedList and executes a local query request for each NamedList in sequence. -->
    <listener event="newSearcher" class="solr.QuerySenderListener">
      <arr name="queries"></arr>
    </listener>

    <listener event="firstSearcher" class="solr.QuerySenderListener">
      <arr name="queries"></arr>
    </listener>

    <!-- If "false" then all requests will block until the first searcher is done warming. -->
    <useColdSearcher>false</useColdSearcher>

  </query>


  <!-- Request Dispatcher -->
  <requestDispatcher>
    
    <!-- Set HTTP caching related parameters -->
    <httpCaching never304="true" />

  </requestDispatcher>

  <!-- Delegates to a sequent of SearchComponents (see below) -->
  <requestHandler name="/select" class="solr.SearchHandler">
  
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <int name="rows">10</int>
    </lst>
    
  </requestHandler>

  <!-- A request handler that returns indented JSON by default -->
  <requestHandler name="/query" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <str name="wt">json</str>
      <str name="indent">true</str>
    </lst>
  </requestHandler>

  <initParams path="/update/**,/query,/select,/spell">
    <lst name="defaults">
      <str name="df">_text_</str>
    </lst>
  </initParams>

  <!-- The spell check component can return a list of alternative spelling -->
  <searchComponent name="spellcheck" class="solr.SpellCheckComponent">

    <str name="queryAnalyzerFieldType">text_general</str>
      -->

    <!-- a spellchecker built from a field of the main index -->
    <lst name="spellchecker">
      <str name="name">default</str>
      <str name="field">_text_</str>
      <str name="classname">solr.DirectSolrSpellChecker</str>
      <!-- the spellcheck distance measure used, the default is the internal levenshtein -->
      <str name="distanceMeasure">internal</str>
      <!-- minimum accuracy needed to be considered a valid spellcheck suggestion -->
      <float name="accuracy">0.5</float>
      <!-- the maximum #edits we consider when enumerating terms: can be 1 or 2 -->
      <int name="maxEdits">2</int>
      <!-- the minimum shared prefix when enumerating terms -->
      <int name="minPrefix">1</int>
      <!-- maximum number of inspections per result. -->
      <int name="maxInspections">5</int>
      <!-- minimum length of a query term to be considered for correction -->
      <int name="minQueryLength">4</int>
      <!-- maximum threshold of documents a query term can appear to be considered for correction -->
      <float name="maxQueryFrequency">0.01</float>
      <!-- uncomment this to require suggestions to occur in 1% of the documents
        <float name="thresholdTokenFrequency">.01</float>
      -->
    </lst>

  </searchComponent>

  <!-- A component to return terms and document frequency of those terms -->
  <searchComponent name="terms" class="solr.TermsComponent"/>

  <!-- A request handler for demonstrating the terms component -->
  <requestHandler name="/terms" class="solr.SearchHandler" startup="lazy">
    <lst name="defaults">
      <bool name="terms">true</bool>
      <bool name="distrib">false</bool>
    </lst>
    <arr name="components">
      <str>terms</str>
    </arr>
  </requestHandler>

  <!-- Highlighting Component -->
  <searchComponent class="solr.HighlightComponent" name="highlight">
    <highlighting>
      <!-- Configure the standard fragmenter -->
      <!-- This could most likely be commented out in the "default" case -->
      <fragmenter name="gap"
                  default="true"
                  class="solr.highlight.GapFragmenter">
        <lst name="defaults">
          <int name="hl.fragsize">100</int>
        </lst>
      </fragmenter>

      <!-- A regular-expression-based fragmenter (for sentence extraction) -->
      <fragmenter name="regex" class="solr.highlight.RegexFragmenter">
        <lst name="defaults">
          <!-- slightly smaller fragsizes work better because of slop -->
          <int name="hl.fragsize">70</int>
          <!-- allow 50% slop on fragment sizes -->
          <float name="hl.regex.slop">0.5</float>
          <!-- a basic sentence pattern -->
          <str name="hl.regex.pattern">[-\w ,/\n\&quot;&apos;]{20,200}</str>
        </lst>
      </fragmenter>

      <!-- Configure the standard formatter -->
      <formatter name="html" default="true" class="solr.highlight.HtmlFormatter">
        <lst name="defaults">
          <str name="hl.simple.pre"><![CDATA[<em>]]></str>
          <str name="hl.simple.post"><![CDATA[</em>]]></str>
        </lst>
      </formatter>

      <!-- Configure the standard encoder -->
      <encoder name="html" class="solr.highlight.HtmlEncoder" />

      <!-- Configure the standard fragListBuilder -->
      <fragListBuilder name="simple" class="solr.highlight.SimpleFragListBuilder"/>

      <!-- Configure the single fragListBuilder -->
      <fragListBuilder name="single" class="solr.highlight.SingleFragListBuilder"/>

      <!-- Configure the weighted fragListBuilder -->
      <fragListBuilder name="weighted" default="true" class="solr.highlight.WeightedFragListBuilder"/>

      <!-- default tag FragmentsBuilder -->
      <fragmentsBuilder name="default" default="true" class="solr.highlight.ScoreOrderFragmentsBuilder">
        <!--
        <lst name="defaults">
          <str name="hl.multiValuedSeparatorChar">/</str>
        </lst>
        -->
      </fragmentsBuilder>

      <!-- multi-colored tag FragmentsBuilder -->
      <fragmentsBuilder name="colored" class="solr.highlight.ScoreOrderFragmentsBuilder">
        <lst name="defaults">
          <str name="hl.tag.pre"><![CDATA[
               <b style="background:yellow">,<b style="background:lawgreen">,
               <b style="background:aquamarine">,<b style="background:magenta">,
               <b style="background:palegreen">,<b style="background:coral">,
               <b style="background:wheat">,<b style="background:khaki">,
               <b style="background:lime">,<b style="background:deepskyblue">]]></str>
          <str name="hl.tag.post"><![CDATA[</b>]]></str>
        </lst>
      </fragmentsBuilder>

      <boundaryScanner name="default" default="true" class="solr.highlight.SimpleBoundaryScanner">
        <lst name="defaults">
          <str name="hl.bs.maxScan">10</str>
          <str name="hl.bs.chars">.,!? &#9;&#10;&#13;</str>
        </lst>
      </boundaryScanner>

      <boundaryScanner name="breakIterator" class="solr.highlight.BreakIteratorBoundaryScanner">
        <lst name="defaults">
          <!-- type should be one of CHARACTER, WORD(default), LINE and SENTENCE -->
          <str name="hl.bs.type">WORD</str>
          <!-- language and country are used when constructing Locale object.  -->
          <!-- And the Locale object will be used when getting instance of BreakIterator -->
          <str name="hl.bs.language">en</str>
          <str name="hl.bs.country">US</str>
        </lst>
      </boundaryScanner>
    </highlighting>
  </searchComponent>

  <!-- Chains of Update Processor Factories for dealing with Update Requests. -->
  <updateProcessor class="solr.UUIDUpdateProcessorFactory" name="uuid"/>
  <updateProcessor class="solr.RemoveBlankFieldUpdateProcessorFactory" name="remove-blank"/>
  <updateProcessor class="solr.FieldNameMutatingUpdateProcessorFactory" name="field-name-mutating">
    <str name="pattern">[^\w-\.]</str>
    <str name="replacement">_</str>
  </updateProcessor>
  <updateProcessor class="solr.ParseBooleanFieldUpdateProcessorFactory" name="parse-boolean"/>
  <updateProcessor class="solr.ParseLongFieldUpdateProcessorFactory" name="parse-long"/>
  <updateProcessor class="solr.ParseDoubleFieldUpdateProcessorFactory" name="parse-double"/>
  <updateProcessor class="solr.ParseDateFieldUpdateProcessorFactory" name="parse-date">
    <arr name="format">
      <str>yyyy-MM-dd['T'[HH:mm[:ss[.SSS]][z</str>
      <str>yyyy-MM-dd['T'[HH:mm[:ss[,SSS]][z</str>
      <str>yyyy-MM-dd HH:mm[:ss[.SSS]][z</str>
      <str>yyyy-MM-dd HH:mm[:ss[,SSS]][z</str>
      <str>[EEE, ]dd MMM yyyy HH:mm[:ss] z</str>
      <str>EEEE, dd-MMM-yy HH:mm:ss z</str>
      <str>EEE MMM ppd HH:mm:ss [z ]yyyy</str>
    </arr>
  </updateProcessor>
  <updateProcessor class="solr.AddSchemaFieldsUpdateProcessorFactory" name="add-schema-fields">
    <lst name="typeMapping">
      <str name="valueClass">java.lang.String</str>
      <str name="fieldType">text_general</str>
      <lst name="copyField">
        <str name="dest">*_str</str>
        <int name="maxChars">256</int>
      </lst>
      <!-- Use as default mapping instead of defaultFieldType -->
      <bool name="default">true</bool>
    </lst>
    <lst name="typeMapping">
      <str name="valueClass">java.lang.Boolean</str>
      <str name="fieldType">booleans</str>
    </lst>
    <lst name="typeMapping">
      <str name="valueClass">java.util.Date</str>
      <str name="fieldType">pdates</str>
    </lst>
    <lst name="typeMapping">
      <str name="valueClass">java.lang.Long</str>
      <str name="valueClass">java.lang.Integer</str>
      <str name="fieldType">plongs</str>
    </lst>
    <lst name="typeMapping">
      <str name="valueClass">java.lang.Number</str>
      <str name="fieldType">pdoubles</str>
    </lst>
  </updateProcessor>

  <!-- The update.autoCreateFields property can be turned to false to disable schemaless mode -->
  <updateRequestProcessorChain name="add-unknown-fields-to-the-schema" default="${update.autoCreateFields:true}"
           processor="uuid,remove-blank,field-name-mutating,parse-boolean,parse-long,parse-double,parse-date,add-schema-fields">
    <processor class="solr.LogUpdateProcessorFactory"/>
    <processor class="solr.DistributedUpdateProcessorFactory"/>
    <processor class="solr.RunUpdateProcessorFactory"/>
  </updateRequestProcessorChain>

  <updateRequestProcessorChain name="geocoder-update-chain" default="true">
    <processor class="solr.TrimFieldUpdateProcessorFactory"/>

    <!-- Remove CO from place names -->
    <processor class="solr.RegexReplaceProcessorFactory">
      <str name="fieldName">PlaceName</str>
      <str name="pattern">(?i)\s+co</str>
      <str name="replacement"></str>
    </processor>

    <!-- Create a LatLon field for spacial search -->
    <processor class="solr.CloneFieldUpdateProcessorFactory"> 
      <str name="source">Latitude</str> 
      <str name="dest">LatLon</str> 
    </processor> 
    <processor class="solr.CloneFieldUpdateProcessorFactory"> 
      <str name="source">Longitude</str> 
      <str name="dest">LatLon</str> 
    </processor> 
    <processor class="solr.ConcatFieldUpdateProcessorFactory"> 
      <str name="fieldName">LatLon</str> 
      <str name="delimiter">,</str> 
    </processor>

    <!-- Create a complete address -->
    <processor class="solr.CloneFieldUpdateProcessorFactory"> 
      <str name="source">AddrFull</str> 
      <str name="dest">AddrComplete</str>
    </processor>
    <processor class="solr.CloneFieldUpdateProcessorFactory"> 
      <str name="source">PlaceName</str> 
      <str name="dest">AddrComplete</str>
    </processor>
    <processor class="solr.DefaultValueUpdateProcessorFactory"> 
      <str name="fieldName">State</str>
      <str name="value">CO</str>
    </processor>
    <processor class="solr.CloneFieldUpdateProcessorFactory"> 
      <str name="source">State</str>
      <str name="dest">AddrComplete</str>
    </processor>
    <processor class="solr.CloneFieldUpdateProcessorFactory"> 
      <str name="source">Zipcode</str>
      <str name="dest">AddrComplete</str>
    </processor>
    <processor class="solr.ConcatFieldUpdateProcessorFactory"> 
      <str name="fieldName">AddrComplete</str> 
      <str name="delimiter">, </str> 
    </processor>

    <!-- Remove fields with NULL values -->
    <processor class="solr.RegexReplaceProcessorFactory">
      <str name="fieldName">NumSuf</str>
      <str name="fieldName">PlaceName</str>
      <str name="fieldName">PreDir</str>
      <str name="fieldName">PreType</str>
      <str name="fieldName">PostType</str>
      <str name="fieldName">PostDir</str>
      <str name="fieldName">UnitType</str>
      <str name="fieldName">UnitNumber</str>
      <str name="fieldName">Zipcode</str>
      <str name="pattern"><![CDATA[(?i)NULL|<Null>]]></str>
      <str name="replacement"></str>
    </processor>
    <processor class="RemoveBlankFieldUpdateProcessorFactory"/>
    
    <!-- Replace NULL fields and trailing commas from AddrComplete -->
    <processor class="solr.RegexReplaceProcessorFactory">
      <str name="fieldName">AddrComplete</str>
      <str name="pattern">(?i),\sNULL|,\s$</str>
      <str name="replacement"></str>
    </processor>

    <processor class="solr.LogUpdateProcessorFactory" /> 
    <processor class="solr.RunUpdateProcessorFactory" />
  </updateRequestProcessorChain>

  <!-- 
    Responses will be written using the writer specified by the 'wt' request parameter
    matching the name of a registered writer.
  -->
  <queryResponseWriter name="json" class="solr.JSONResponseWriter" />

</config>
